{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "프로젝트 구조 스켈레톤 생성",
        "description": "CAST 프로젝트의 전체 디렉토리 구조와 초기 설정 파일들을 생성",
        "details": "다음 구조를 생성합니다:\n- flake.nix: inputs에 nixpkgs, rust-overlay 포함, outputs에 lib, packages, devShells 정의\n- lib/: default.nix에서 모든 라이브러리 함수 export\n- lib/mkDataset.nix: 스텁 함수 { name, version, manifest, storePath ? null }: derivation\n- lib/fetchDatabase.nix: 스텁 함수 { name, url, hash ? null, extract ? false, metadata ? {} }: manifest\n- lib/transform.nix: 스텁 함수 { name, src, builder, outputs ? [\"out\"] }: derivation\n- lib/symlinkSubset.nix: 스텁 함수 { name, paths }: derivation\n- lib/manifest.nix: readManifest, hashToPath, manifestToEnv 유틸리티 함수\n- lib/types.nix: Nix 타입 정의 (manifestType, datasetType 등)\n- packages/cast-cli/: Cargo.toml, src/main.rs 초기 구조\n- schemas/: manifest-v1.json, config-v1.json 플레이스홀더\n- examples/: simple-dataset/, transformation/, registry/ 디렉토리\n- dev/: formatter.nix (alejandra 사용), shell.nix (rust-analyzer, cargo-watch 포함)",
        "testStrategy": "nix flake check가 성공적으로 실행되는지 확인, nix develop로 개발 셸 진입 가능 여부 테스트, 모든 디렉토리가 생성되었는지 확인",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "flake.nix와 기본 Nix 설정 파일 생성",
            "description": "프로젝트 루트에 flake.nix 파일을 생성하고 nixpkgs, rust-overlay를 inputs로 설정하며, outputs에 lib, packages, devShells를 정의합니다.",
            "dependencies": [],
            "details": "flake.nix 파일을 생성하여 inputs에 nixpkgs와 rust-overlay를 추가하고, outputs 섹션에서 lib (Nix 라이브러리 함수들), packages (cast-cli), devShells (개발 환경)를 정의합니다. 또한 flake.lock 파일이 생성되도록 nix flake update를 실행하고, .gitignore에 필요한 항목들을 추가합니다.\n<info added on 2025-11-17T15:24:35.832Z>\nflake.nix 설정 성공적으로 완료:\n- flake inputs에 rust-overlay 입력 추가 (nixpkgs를 따르도록 설정)\n- pkgs 인스턴스화에서 rust-overlay 오버레이 구성\n- flake.outputs 섹션에 빈 lib 출력 추가 (task 1.2를 위한 플레이스홀더)\n- .gitignore에 Rust 관련 항목 업데이트 (target/, Cargo.lock, *.rs.bk, *.pdb)\n- nix flake update로 flake.lock 업데이트\n- nix flake check로 검증 (모든 체크 통과)\n- nix flake show로 출력 확인 (lib, devShells, formatter, checks 모두 확인됨)\n</info added on 2025-11-17T15:24:35.832Z>",
            "status": "done",
            "testStrategy": "nix flake check 명령이 오류 없이 실행되는지 확인하고, nix flake show로 모든 outputs가 올바르게 표시되는지 검증합니다."
          },
          {
            "id": 2,
            "title": "lib/ 디렉토리와 모든 Nix 라이브러리 스텁 파일 생성",
            "description": "lib 디렉토리를 생성하고 mkDataset.nix, fetchDatabase.nix, transform.nix, symlinkSubset.nix, manifest.nix, types.nix 파일들을 스텁 함수로 구현합니다.",
            "dependencies": [
              1
            ],
            "details": "lib/default.nix를 생성하여 모든 라이브러리 함수를 export하고, 각 개별 파일(mkDataset.nix, fetchDatabase.nix, transform.nix, symlinkSubset.nix, manifest.nix, types.nix)에 스텁 함수를 구현합니다. 각 함수는 올바른 시그니처를 가지되 실제 구현은 플레이스홀더로 남겨둡니다. types.nix에는 manifestType, datasetType 등의 Nix 타입 정의를 추가합니다.\n<info added on 2025-11-17T15:29:28.765Z>\n구현 완료 내역:\n\nlib/ 디렉토리 구조 생성:\n- lib/default.nix: nixpkgs lib과 pkgs를 받아 모든 라이브러리 함수 export (fetchDatabase, manifest, mkDataset, symlinkSubset, transform, types)\n- lib/mkDataset.nix: 데이터셋 derivation 생성 스텁, 시그니처 {name, version, manifest, storePath?}로 구현\n- lib/fetchDatabase.nix: 데이터베이스 다운로드 및 등록 스텁, 시그니처 {name, url, hash?, extract?, metadata?}로 구현  \n- lib/transform.nix: 데이터 변환 파이프라인 스텁, 시그니처 {name, src, builder, outputs?}로 구현\n- lib/symlinkSubset.nix: 심링크 서브셋 생성 스텁, 시그니처 {name, paths}로 구현\n- lib/manifest.nix: 매니페스트 유틸리티 함수 3개 export (readManifest, hashToPath, manifestToEnv)\n- lib/types.nix: Nix 타입 정의 - manifestType, datasetType, sourceType, contentType, transformationType 포함\n\nflake.nix 업데이트:\n- lib 속성을 ./lib import로 설정, nixpkgs lib과 pkgs 인스턴스 전달\n\n검증 결과:\n- `nix eval .#lib` 실행 시 6개 export 모두 나열됨 \n- mkDataset 인자: manifest, name, storePath(옵션), version 확인\n- fetchDatabase 인자: extract(옵션), hash(옵션), metadata(옵션), name, url 확인\n- manifest.{hashToPath, manifestToEnv, readManifest} 3개 유틸리티 함수 export 확인\n- 모든 스텁 함수가 플레이스홀더 반환, 추후 구현을 위한 준비 완료\n</info added on 2025-11-17T15:29:28.765Z>",
            "status": "done",
            "testStrategy": "nix eval .#lib로 라이브러리 함수들이 올바르게 export되는지 확인하고, 각 함수가 올바른 인자를 받아들이는지 테스트합니다."
          },
          {
            "id": 3,
            "title": "Rust CLI 프로젝트 초기 구조 설정",
            "description": "packages/cast-cli 디렉토리에 Cargo.toml과 기본 Rust 프로젝트 구조를 설정하고 초기 main.rs 파일을 생성합니다.",
            "dependencies": [
              1
            ],
            "details": "packages/cast-cli/Cargo.toml 파일을 생성하여 프로젝트 메타데이터와 필요한 의존성(blake3, sqlx, tokio, anyhow, clap 등)을 정의합니다. src/main.rs에 기본 CLI 구조를 구현하고, src/storage/mod.rs, src/hash.rs, src/manifest.rs, src/db.rs 파일들을 플레이스홀더로 생성합니다. 또한 README.md 파일을 추가하여 CLI 도구의 목적과 사용법을 간단히 문서화합니다.\n<info added on 2025-11-17T15:37:31.770Z>\n구현 완료 상세 내역:\n\n성공적으로 생성된 파일들:\n- packages/cast-cli/Cargo.toml: blake3, tokio, sqlx, clap, serde 등 모든 필수 의존성 명시\n- packages/cast-cli/src/main.rs: clap derive를 사용한 CLI 인터페이스 (put, get, fetch, transform, gc 명령어 구현)\n- packages/cast-cli/src/storage/mod.rs: StorageBackend trait 정의 (put, get, exists, delete 메서드)\n- packages/cast-cli/src/storage/backend.rs: trait 정의\n- packages/cast-cli/src/storage/local.rs: LocalStorage 구현체 스텁\n- packages/cast-cli/src/hash.rs: Blake3Hash 구조체 구현 (from_file, from_bytes, to_string, verify 메서드)\n- packages/cast-cli/src/manifest.rs: 스키마 v1.0과 일치하는 완전한 Manifest 타입 정의 (Dataset, Source, Content, Transformation)\n- packages/cast-cli/src/db.rs: MetadataDb async 래퍼 구현 (new, register_object, find_datasets_by_name)\n- packages/cast-cli/README.md: CLI 명령어 사용법, 빌드, 테스트 방법 문서화\n\n검증 결과:\n- cargo build: 15.70초 만에 성공적으로 빌드 완료 (스텁 코드로 인한 예상된 dead_code 경고 발생)\n- cargo test: 4개 테스트 모두 통과 (test_cli_parsing, test_hash_from_bytes, test_manifest_serialization, test_db_creation)\n- nix fmt: 28개 파일 처리, 2개 파일 포맷팅 적용\n\nJujutsu 커밋: mtkpqxvs 088a27ee \"feat(task-1.3): implement Rust CLI project structure\"\n</info added on 2025-11-17T15:37:31.770Z>",
            "status": "done",
            "testStrategy": "cargo build --manifest-path packages/cast-cli/Cargo.toml 명령이 성공적으로 실행되는지 확인하고, cargo test로 기본 테스트가 통과하는지 검증합니다."
          },
          {
            "id": 4,
            "title": "스키마와 예제 디렉토리 구조 생성",
            "description": "schemas 디렉토리에 JSON 스키마 파일들을 생성하고, examples 디렉토리에 사용 예제를 위한 하위 디렉토리들을 구성합니다.",
            "dependencies": [],
            "details": "schemas/manifest-v1.json과 schemas/config-v1.json 파일을 플레이스홀더로 생성하여 기본 JSON 스키마 구조를 정의합니다. examples 디렉토리 아래에 simple-dataset/, transformation/, registry/ 하위 디렉토리를 생성하고 각각에 빈 README.md 파일을 추가합니다. 추후 구현될 예제들의 기반이 될 디렉토리 구조를 미리 준비합니다.",
            "status": "done",
            "testStrategy": "모든 디렉토리가 올바르게 생성되었는지 find 명령으로 확인하고, tree 명령으로 전체 구조를 검증합니다."
          },
          {
            "id": 5,
            "title": "개발 환경 설정 파일 작성",
            "description": "dev 디렉토리에 formatter.nix와 shell.nix 파일을 생성하여 개발 환경을 구성합니다.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "dev/formatter.nix 파일을 생성하여 alejandra를 코드 포매터로 설정하고, dev/shell.nix에서 rust-analyzer, cargo-watch, clippy, rustfmt 등 Rust 개발에 필요한 도구들을 포함하는 개발 셸을 정의합니다. 또한 환경 변수 설정과 셸 hook을 추가하여 개발자가 nix develop 명령으로 즉시 개발을 시작할 수 있도록 구성합니다.",
            "status": "done",
            "testStrategy": "nix develop 명령으로 개발 셸에 진입할 수 있는지 확인하고, 셸 내에서 cargo, rust-analyzer 등의 도구가 사용 가능한지 검증합니다."
          }
        ]
      },
      {
        "id": 2,
        "title": "Manifest JSON 스키마 정의",
        "description": "데이터셋 메타데이터를 위한 JSON 스키마 v1 정의 및 문서화",
        "details": "schemas/manifest-v1.json 파일 생성:\n```json\n{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"type\": \"object\",\n  \"required\": [\"schema_version\", \"dataset\", \"source\", \"contents\"],\n  \"properties\": {\n    \"schema_version\": { \"type\": \"string\", \"const\": \"1.0\" },\n    \"dataset\": {\n      \"type\": \"object\",\n      \"required\": [\"name\", \"version\"],\n      \"properties\": {\n        \"name\": { \"type\": \"string\" },\n        \"version\": { \"type\": \"string\" },\n        \"description\": { \"type\": \"string\" }\n      }\n    },\n    \"source\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"url\": { \"type\": \"string\", \"format\": \"uri\" },\n        \"download_date\": { \"type\": \"string\", \"format\": \"date-time\" },\n        \"server_mtime\": { \"type\": \"string\", \"format\": \"date-time\" },\n        \"archive_hash\": { \"type\": \"string\", \"pattern\": \"^blake3:[a-f0-9]{64}$\" }\n      }\n    },\n    \"contents\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"object\",\n        \"required\": [\"path\", \"hash\", \"size\"],\n        \"properties\": {\n          \"path\": { \"type\": \"string\" },\n          \"hash\": { \"type\": \"string\", \"pattern\": \"^blake3:[a-f0-9]{64}$\" },\n          \"size\": { \"type\": \"integer\", \"minimum\": 0 },\n          \"executable\": { \"type\": \"boolean\", \"default\": false }\n        }\n      }\n    },\n    \"transformations\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"object\",\n        \"required\": [\"type\", \"from\"],\n        \"properties\": {\n          \"type\": { \"type\": \"string\" },\n          \"from\": { \"type\": \"string\" },\n          \"params\": { \"type\": \"object\" }\n        }\n      }\n    }\n  }\n}\n```\nJSON Schema 검증 도구 (ajv-cli) 통합도 포함",
        "testStrategy": "ajv-cli를 사용한 스키마 검증 테스트, 예제 매니페스트 파일들이 스키마를 통과하는지 확인, 잘못된 매니페스트가 실패하는지 테스트",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Nix 라이브러리 API 구현",
        "description": "cast.lib.* 네임스페이스의 핵심 Nix 함수들을 구현",
        "details": "lib/default.nix에서 모든 함수 export:\n```nix\n{ lib, pkgs, ... }:\nrec {\n  mkDataset = import ./mkDataset.nix { inherit lib pkgs; };\n  fetchDatabase = import ./fetchDatabase.nix { inherit lib pkgs mkDataset; };\n  transform = import ./transform.nix { inherit lib pkgs; };\n  symlinkSubset = import ./symlinkSubset.nix { inherit lib pkgs; };\n  manifest = import ./manifest.nix { inherit lib; };\n  types = import ./types.nix { inherit lib; };\n}\n```\n\n각 함수 구현:\n- mkDataset: manifest를 읽고 심링크 팜을 생성하는 derivation 빌드\n- fetchDatabase: curl/wget으로 다운로드 후 cast-cli put 호출\n- transform: CAST_OUTPUT 환경변수 설정 후 builder 실행\n- symlinkSubset: 선택적 심링크 생성\n- manifest.readManifest: JSON 파싱\n- manifest.hashToPath: 해시를 CAS 경로로 변환\n- manifest.manifestToEnv: 환경변수 생성",
        "testStrategy": "각 함수에 대한 Nix 평가 테스트, flake.nix checks 속성에 테스트 추가, 예제 사용 케이스로 통합 테스트",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "lib/default.nix 파일 생성 및 기본 export 구조 설정",
            "description": "Nix 라이브러리의 진입점인 lib/default.nix 파일을 생성하고, 모든 하위 모듈을 import하여 export하는 기본 구조를 구현합니다.",
            "dependencies": [],
            "details": "lib/default.nix 파일을 생성하여 mkDataset, fetchDatabase, transform, symlinkSubset, manifest, types 모듈을 import하고 rec 속성셋으로 export합니다. 각 모듈 파일의 스켈레톤도 함께 생성하여 후속 작업이 가능하도록 합니다.",
            "status": "done",
            "testStrategy": "nix eval로 라이브러리가 올바르게 로드되는지 확인, 각 함수가 접근 가능한지 테스트"
          },
          {
            "id": 2,
            "title": "mkDataset 함수 구현 - manifest 읽기 및 심링크 팜 생성",
            "description": "manifest.json을 읽어서 CAS 저장소의 실제 파일들을 가리키는 심링크 팜을 생성하는 Nix derivation을 빌드하는 mkDataset 함수를 구현합니다.",
            "dependencies": [
              1
            ],
            "details": "lib/mkDataset.nix에서 manifest를 파싱하여 각 파일의 BLAKE3 해시를 CAS 경로로 변환하고, /nix/store에 심링크 팜을 생성하는 derivation을 구현합니다. CAST_STORE 환경변수와 storePath 파라미터를 지원하며, 환경변수 export 기능도 포함합니다.\n<info added on 2025-11-17T15:59:34.907Z>\nmkDataset 함수 구현 완료:\n\n주요 구현 내용:\n- manifest를 경로(자동 파싱) 또는 attrset으로 직접 받아 처리\n- CAST 저장소 경로 우선순위: storePath 파라미터 > CAST_STORE 환경변수 > ~/.cache/cast 기본값\n- 디렉토리 구조를 보존하며 완전한 심링크 팜 생성\n- jq를 사용하여 manifest 파싱 및 빌드 중 심링크 생성\n- 해시-경로 변환 규칙: store/{hash[:2]}/{hash[2:4]}/{full_hash}\n- 출력 구조: data/ (심링크), manifest.json, dataset-info.json\n- passthru 속성: manifestData, castStorePath, shellVars로 셸 통합 지원\n- 환경변수 자동 설정: CAST_DATASET_<NAME>, _VERSION, _MANIFEST\n\n테스트 결과:\n- 함수 시그니처 검증 완료: manifest, name, storePath, version\n- nix flake check: 모든 체크 통과\n- nix fmt: 코드 포맷팅 완료\n\n커밋: yzmlzpqu 70532253\n</info added on 2025-11-17T15:59:34.907Z>",
            "status": "done",
            "testStrategy": "테스트 manifest로 derivation 빌드 확인, 생성된 심링크가 올바른 CAS 경로를 가리키는지 검증"
          },
          {
            "id": 3,
            "title": "fetchDatabase 함수 구현 - 데이터베이스 다운로드 및 CAS 등록",
            "description": "원격 URL에서 데이터베이스를 다운로드하고 cast-cli를 통해 CAS에 저장한 후 manifest를 생성하는 fetchDatabase 함수를 구현합니다.",
            "dependencies": [
              2
            ],
            "details": "lib/fetchDatabase.nix에서 curl/wget을 사용하여 데이터를 다운로드하고, cast-cli put 명령으로 CAS에 저장합니다. 아카이브 자동 추출 옵션을 지원하며, 다운로드 메타데이터(URL, 시간, 서버 mtime)를 manifest에 포함시킵니다.\n<info added on 2025-11-18T00:26:55.446Z>\n성공적으로 lib/fetchDatabase.nix 구현 완료:\n\n핵심 구현 내용:\n- 다운로드: curl 사용하여 리디렉션 추적, 에러 시 실패, 통계 및 Last-Modified 헤더 캡처\n- 해싱: b3sum으로 BLAKE3 해시 계산 및 검증\n- 추출 모드: 아카이브 타입 자동 감지 (tar.gz, tar.bz2, tar.xz, zip, gz), 각 파일별 해시 포함한 전체 파일 인벤토리 생성\n- 비추출 모드: 아카이브를 단일 파일로 저장, 아카이브 해시 사용\n- Manifest 생성: 스키마 v1.0 준수 - dataset, source, contents, transformations 포함\n- mkDataset 통합: 심링크 팜이 포함된 완전한 dataset derivation 반환\n\n주요 기능:\n- 해시 검증: 예상 해시와 실제 해시가 일치하지 않으면 빌드 실패\n- 버전 처리: metadata.version 사용하거나 타임스탬프 기본값 적용\n- 메타데이터 캡처: URL, 다운로드 타임스탬프, 서버 mtime, 아카이브 해시\n- 파일 인벤토리: 각 파일의 경로, BLAKE3 해시, 크기, 실행 권한\n- 포괄적인 아카이브 지원: tar.gz/bz2/xz, zip, plain gz\n\n테스트 결과:\n- 함수 시그니처 확인: extract, hash, metadata, name, url (5개 파라미터)\n- nix flake check: 모든 체크 통과\n- nix fmt: 성공적으로 포맷팅 완료\n\n커밋: tzvzrlmw e3af2d6e\n</info added on 2025-11-18T00:26:55.446Z>",
            "status": "done",
            "testStrategy": "mock URL로 다운로드 테스트, cast-cli 호출 검증, 생성된 manifest 구조 확인"
          },
          {
            "id": 4,
            "title": "transform 함수 구현 - 데이터 변환 파이프라인",
            "description": "입력 데이터셋을 받아 변환 작업을 수행하고 결과를 CAS에 저장하는 transform 함수를 구현합니다.",
            "dependencies": [
              2
            ],
            "details": "lib/transform.nix에서 CAST_OUTPUT 환경변수를 설정하고 사용자 정의 builder 스크립트를 실행합니다. 변환 결과는 cast-cli를 통해 CAS에 저장되며, provenance 체인이 manifest에 기록됩니다. 캐싱 메커니즘도 구현하여 동일한 변환은 재실행하지 않도록 합니다.\n<info added on 2025-11-18T00:48:13.251Z>\n구현 완료 내역:\n\nlib/transform.nix 성공적으로 구현됨:\n\n핵심 구현 사항:\n- 소스 처리: CAST 데이터셋이나 임의 소스에서 manifest 읽기, 아카이브와 디렉토리 모두 지원\n- 변환 실행: CAST_OUTPUT, CAST_TRANSFORM_NAME, CAST_TRANSFORM_PARAMS 환경변수 설정, builder(경로 또는 인라인) 실행\n- 출력 처리: 모든 출력 파일에 대한 BLAKE3 해시 생성, 비어있지 않은 출력 검증\n- Provenance 추적: transformations 배열에 변환 타입, 소스 해시, 파라미터 기록, 전체 계보 보존\n- Manifest 생성: dataset, source, contents, transformations(전체 provenance 체인) 포함한 스키마 v1.0\n- mkDataset 통합: 심링크 팜이 포함된 완전한 dataset derivation 반환\n\n주요 기능:\n- Builder 환경: SOURCE_DATA, CAST_OUTPUT, CAST_TRANSFORM_NAME, CAST_TRANSFORM_PARAMS\n- Provenance 체인: 소스의 기존 transformations 배열에 추가\n- 버전 상속: 소스 버전 사용 또는 기본값 \"transformed\"\n- 출력 검증: builder가 출력을 생성하지 않으면 실패\n- 파일 목록: 각 파일에 대한 경로, BLAKE3 해시, 크기, 실행 가능 여부\n\n테스트 결과:\n- 함수 시그니처 확인됨: builder, name, params, src\n- nix flake check: 모든 체크 통과\n- nix fmt: 성공적으로 포맷팅됨\n\n커밋: sxzvkksl c30b28a4\n</info added on 2025-11-18T00:48:13.251Z>",
            "status": "done",
            "testStrategy": "간단한 변환(파일 복사) 테스트, 복잡한 변환(압축 해제) 테스트, 캐싱 작동 확인"
          },
          {
            "id": 5,
            "title": "symlinkSubset과 manifest 유틸리티 함수 구현",
            "description": "데이터셋의 부분 집합을 위한 심링크를 생성하는 symlinkSubset과 manifest 관련 유틸리티 함수들을 구현합니다.",
            "dependencies": [
              1
            ],
            "details": "lib/symlinkSubset.nix에서 지정된 경로들만 포함하는 선택적 심링크 팜을 생성합니다. lib/manifest.nix에서 readManifest(JSON 파싱), hashToPath(해시→CAS 경로 변환), manifestToEnv(환경변수 생성) 유틸리티 함수를 구현합니다.\n<info added on 2025-11-18T01:05:54.914Z>\nsymlinkSubset.nix 완전 구현:\n- 경로 정규화: .data 속성이 있는 dataset, {name, path} 쌍, 일반 경로를 모두 처리\n- 심링크 생성: 하위 디렉토리 생성, 구조 유지, 파일 및 심링크 처리\n- 파일 인벤토리: 심링크 타겟에서 BLAKE3 해시 추출, 크기 및 권한 추적\n- Manifest 생성: subset:// URL 스킴을 사용한 스키마 v1.0\n- 파라미터: name, paths(리스트), version(선택적, 기본값 1.0)\n- Passthru 속성: name, paths, version, manifestPath, normalizedPaths\n\nmanifest.nix 유틸리티 함수 확장:\n- manifestToEnv: dataPath 파라미터 추가, _NAME 변수도 반환하도록 개선\n- validateManifest: 필수 필드(schema_version, dataset, source, contents) 검증\n- getFileHashes: contents 배열에서 모든 해시 추출\n- getTotalSize: foldl로 파일 크기 합계 계산\n- filterByPath: 경로 패턴으로 필터링된 manifest 생성\n- getTransformationChain: transformations 배열 반환 (없으면 빈 리스트)\n- getSourceHash: source.archive_hash 반환 (없으면 blake3:unknown)\n\n테스트 완료:\n- 함수 시그니처 검증: name, paths, version 확인\n- Manifest 유틸리티: 9개 함수 export 확인 (filterByPath, getFileHashes, getSourceHash, getTotalSize, getTransformationChain, hashToPath, manifestToEnv, readManifest, validateManifest)\n- nix flake check: 모든 체크 통과\n- nix fmt: 코드 포맷팅 성공\n\n커밋: mnqtnwwm f1fbc7c4\n</info added on 2025-11-18T01:05:54.914Z>",
            "status": "done",
            "testStrategy": "부분 집합 생성 테스트, manifest 파싱 정확성 검증, 환경변수 생성 확인"
          },
          {
            "id": 6,
            "title": "types.nix 타입 정의 및 flake.nix checks 테스트 작성",
            "description": "Nix 라이브러리 함수들의 입력 파라미터 타입을 정의하고, flake.nix의 checks 속성에 통합 테스트를 추가합니다.",
            "dependencies": [
              2,
              3,
              4,
              5
            ],
            "details": "lib/types.nix에서 lib.types를 사용하여 manifest, dataset, transformation 등의 타입을 정의합니다. flake.nix의 checks 속성에 각 라이브러리 함수의 평가 테스트와 통합 테스트를 추가하여 nix flake check로 모든 테스트를 실행할 수 있도록 합니다.",
            "status": "done",
            "testStrategy": "타입 체크 테스트, 각 함수의 파라미터 검증, 통합 시나리오 테스트, CI에서 자동 실행 가능성 확인"
          }
        ]
      },
      {
        "id": 4,
        "title": "Rust CLI 기본 구조 설정",
        "description": "cast-cli Rust 프로젝트의 기초를 구축하고 명령어 파싱 구현",
        "details": "packages/cast-cli/Cargo.toml:\n```toml\n[package]\nname = \"cast-cli\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[dependencies]\nblake3 = \"1.5\"\ntokio = { version = \"1.40\", features = [\"full\"] }\nsqlx = { version = \"0.8\", features = [\"runtime-tokio\", \"sqlite\"] }\nclap = { version = \"4.5\", features = [\"derive\"] }\nanyhow = \"1.0\"\nthiserror = \"2.0\"\ntracing = \"0.1\"\ntracing-subscriber = { version = \"0.3\", features = [\"env-filter\"] }\nserde = { version = \"1.0\", features = [\"derive\"] }\nserde_json = \"1.0\"\n```\n\nsrc/main.rs:\n```rust\nuse clap::{Parser, Subcommand};\nuse anyhow::Result;\n\n#[derive(Parser)]\n#[command(name = \"cast\")]\n#[command(about = \"Content-Addressed Storage Tool\")]\nstruct Cli {\n    #[command(subcommand)]\n    command: Commands,\n}\n\n#[derive(Subcommand)]\nenum Commands {\n    Put { file: String },\n    Get { hash: String },\n    Fetch { url: String },\n    Transform { manifest: String },\n    Gc { #[arg(long)] dry_run: bool },\n}\n\n#[tokio::main]\nasync fn main() -> Result<()> {\n    tracing_subscriber::fmt::init();\n    let cli = Cli::parse();\n    // 명령어 처리\n    Ok(())\n}\n```\n\n모듈 구조:\n- src/storage/mod.rs: StorageBackend trait 정의\n- src/storage/local.rs: LocalStorage 구현\n- src/hash.rs: BLAKE3 해싱 함수\n- src/manifest.rs: Manifest 타입 및 직렬화\n- src/db.rs: SQLite 연산",
        "testStrategy": "cargo test로 유닛 테스트, cargo clippy로 lint 검사, 각 명령어가 올바른 인자로 파싱되는지 테스트",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "BLAKE3 해싱 구현",
        "description": "효율적인 BLAKE3 컨텐츠 해싱을 Rust로 구현",
        "details": "src/hash.rs 구현:\n```rust\nuse blake3::{Hasher, Hash};\nuse std::fs::File;\nuse std::io::{self, Read, BufReader};\nuse std::path::Path;\nuse anyhow::Result;\n\npub struct Blake3Hash(Hash);\n\nimpl Blake3Hash {\n    pub fn from_file<P: AsRef<Path>>(path: P) -> Result<Self> {\n        let file = File::open(path)?;\n        let mut reader = BufReader::with_capacity(1024 * 1024, file);\n        let mut hasher = Hasher::new();\n        let mut buffer = [0u8; 16384];\n        \n        loop {\n            let bytes_read = reader.read(&mut buffer)?;\n            if bytes_read == 0 { break; }\n            hasher.update(&buffer[..bytes_read]);\n        }\n        \n        Ok(Blake3Hash(hasher.finalize()))\n    }\n    \n    pub fn from_bytes(data: &[u8]) -> Self {\n        Blake3Hash(blake3::hash(data))\n    }\n    \n    pub fn to_string(&self) -> String {\n        format!(\"blake3:{}\", self.0.to_hex())\n    }\n    \n    pub fn verify(&self, other: &str) -> bool {\n        other == self.to_string()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    \n    #[test]\n    fn test_hash_bytes() {\n        let data = b\"hello world\";\n        let hash = Blake3Hash::from_bytes(data);\n        assert!(hash.to_string().starts_with(\"blake3:\"));\n    }\n}\n```\n\n대용량 파일을 위한 스트리밍 처리, 병렬 해싱 지원 추가",
        "testStrategy": "알려진 입력에 대한 해시 값 검증, 대용량 파일 해싱 성능 테스트, 동일 파일에 대한 일관된 해시 생성 확인",
        "priority": "medium",
        "dependencies": [
          4
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "로컬 스토리지 백엔드 구현",
        "description": "계층적 디렉토리 구조를 가진 로컬 파일시스템 스토리지 구현",
        "details": "src/storage/backend.rs:\n```rust\nuse async_trait::async_trait;\nuse std::path::PathBuf;\nuse anyhow::Result;\nuse crate::hash::Blake3Hash;\nuse crate::manifest::Manifest;\n\n#[async_trait]\npub trait StorageBackend: Send + Sync {\n    async fn put(&self, data: impl Read + Send) -> Result<Blake3Hash>;\n    async fn get(&self, hash: &Blake3Hash) -> Result<PathBuf>;\n    async fn exists(&self, hash: &Blake3Hash) -> bool;\n    async fn delete(&self, hash: &Blake3Hash) -> Result<()>;\n    async fn register_dataset(&self, manifest: &Manifest) -> Result<()>;\n}\n```\n\nsrc/storage/local.rs:\n```rust\nuse super::StorageBackend;\nuse std::path::{Path, PathBuf};\nuse tokio::fs;\nuse tokio::io::AsyncWriteExt;\n\npub struct LocalStorage {\n    root: PathBuf,\n}\n\nimpl LocalStorage {\n    pub fn new(root: impl AsRef<Path>) -> Self {\n        LocalStorage { root: root.as_ref().to_path_buf() }\n    }\n    \n    fn hash_to_path(&self, hash: &Blake3Hash) -> PathBuf {\n        let hex = hash.to_string().strip_prefix(\"blake3:\").unwrap();\n        self.root\n            .join(\"store\")\n            .join(&hex[..2])\n            .join(&hex[2..4])\n            .join(hex)\n    }\n}\n\n#[async_trait]\nimpl StorageBackend for LocalStorage {\n    async fn put(&self, mut data: impl Read + Send) -> Result<Blake3Hash> {\n        let mut buffer = Vec::new();\n        data.read_to_end(&mut buffer)?;\n        let hash = Blake3Hash::from_bytes(&buffer);\n        let path = self.hash_to_path(&hash);\n        \n        fs::create_dir_all(path.parent().unwrap()).await?;\n        let mut file = fs::File::create(path).await?;\n        file.write_all(&buffer).await?;\n        \n        Ok(hash)\n    }\n    // 나머지 메서드 구현...\n}\n```\n\n설정 로딩: CAST_STORE 환경변수 > config.toml > ~/.cache/cast",
        "testStrategy": "임시 디렉토리에서 put/get 연산 테스트, 해시 충돌 처리 테스트, 동시 접근 테스트, 참조 카운팅 테스트",
        "priority": "medium",
        "dependencies": [
          5
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "SQLite 메타데이터 데이터베이스 구현",
        "description": "객체, 데이터셋, 변환 추적을 위한 SQLite 스키마 및 연산 구현",
        "details": "src/db.rs 구현:\n```rust\nuse sqlx::{SqlitePool, migrate::MigrateDatabase};\nuse anyhow::Result;\n\npub struct MetadataDb {\n    pool: SqlitePool,\n}\n\nimpl MetadataDb {\n    pub async fn new(db_path: &str) -> Result<Self> {\n        if !sqlx::Sqlite::database_exists(db_path).await? {\n            sqlx::Sqlite::create_database(db_path).await?;\n        }\n        \n        let pool = SqlitePool::connect(db_path).await?;\n        \n        // 스키마 생성\n        sqlx::query(\n            r#\"\n            CREATE TABLE IF NOT EXISTS objects (\n                hash TEXT PRIMARY KEY,\n                size INTEGER NOT NULL,\n                refs INTEGER DEFAULT 1,\n                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n                metadata TEXT\n            );\n            \n            CREATE TABLE IF NOT EXISTS datasets (\n                id INTEGER PRIMARY KEY AUTOINCREMENT,\n                name TEXT NOT NULL,\n                version TEXT NOT NULL,\n                manifest_hash TEXT NOT NULL,\n                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n                UNIQUE(name, version),\n                FOREIGN KEY (manifest_hash) REFERENCES objects(hash)\n            );\n            \n            CREATE TABLE IF NOT EXISTS transformations (\n                id INTEGER PRIMARY KEY AUTOINCREMENT,\n                input_hash TEXT NOT NULL,\n                output_hash TEXT NOT NULL,\n                transform_type TEXT NOT NULL,\n                params TEXT,\n                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n                FOREIGN KEY (input_hash) REFERENCES objects(hash),\n                FOREIGN KEY (output_hash) REFERENCES objects(hash)\n            );\n            \n            CREATE INDEX IF NOT EXISTS idx_objects_refs ON objects(refs);\n            CREATE INDEX IF NOT EXISTS idx_datasets_name ON datasets(name);\n            CREATE INDEX IF NOT EXISTS idx_transformations_input ON transformations(input_hash);\n            \"#\n        ).execute(&pool).await?;\n        \n        Ok(MetadataDb { pool })\n    }\n    \n    pub async fn register_object(&self, hash: &str, size: i64, metadata: Option<String>) -> Result<()> {\n        sqlx::query(\n            \"INSERT INTO objects (hash, size, metadata) VALUES (?, ?, ?)\n             ON CONFLICT(hash) DO UPDATE SET refs = refs + 1\"\n        )\n        .bind(hash)\n        .bind(size)\n        .bind(metadata)\n        .execute(&self.pool)\n        .await?;\n        Ok(())\n    }\n    \n    pub async fn find_datasets_by_name(&self, name: &str) -> Result<Vec<DatasetRecord>> {\n        let records = sqlx::query_as::<_, DatasetRecord>(\n            \"SELECT * FROM datasets WHERE name = ? ORDER BY created_at DESC\"\n        )\n        .bind(name)\n        .fetch_all(&self.pool)\n        .await?;\n        Ok(records)\n    }\n}\n```\n\n마이그레이션 시스템, 연결 풀링, 트랜잭션 지원 포함",
        "testStrategy": "스키마 생성 테스트, CRUD 연산 테스트, 참조 카운팅 정확성 테스트, 동시성 테스트, 마이그레이션 테스트",
        "priority": "medium",
        "dependencies": [
          6
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "SQLite 연결 풀과 데이터베이스 초기화 구현",
            "description": "SQLite 데이터베이스 연결 풀 설정과 초기화 로직을 구현하여 안정적인 데이터베이스 접근 기반을 마련합니다",
            "dependencies": [],
            "details": "sqlx::SqlitePool을 사용하여 연결 풀을 설정하고, 데이터베이스 파일이 없을 경우 자동으로 생성하는 로직을 구현합니다. 연결 풀 크기, 타임아웃, 재시도 정책 등의 설정을 포함하며, 데이터베이스 경로 유효성 검사와 에러 처리를 구현합니다",
            "status": "done",
            "testStrategy": "연결 풀 생성 테스트, 데이터베이스 파일 자동 생성 확인, 동시 연결 처리 테스트, 연결 실패 시 재시도 동작 검증"
          },
          {
            "id": 2,
            "title": "스키마 생성과 마이그레이션 시스템 구축",
            "description": "데이터베이스 스키마를 생성하고 버전 관리를 위한 마이그레이션 시스템을 구현합니다",
            "dependencies": [
              1
            ],
            "details": "objects, datasets, transformations 테이블과 필요한 인덱스를 생성하는 SQL 쿼리를 구현합니다. sqlx migrate 기능을 활용하여 스키마 버전을 관리하고, 향후 스키마 변경을 위한 마이그레이션 파일 구조를 설정합니다. 스키마 버전 체크와 자동 업그레이드 기능을 포함합니다",
            "status": "done",
            "testStrategy": "스키마 생성 검증, 마이그레이션 적용 테스트, 스키마 버전 업그레이드 시나리오 테스트, 롤백 기능 확인"
          },
          {
            "id": 3,
            "title": "objects 테이블 CRUD 연산 구현",
            "description": "콘텐츠 주소 지정 객체를 관리하기 위한 objects 테이블의 모든 CRUD 연산을 구현합니다",
            "dependencies": [
              2
            ],
            "details": "register_object, get_object, update_refs, delete_object 등의 메서드를 구현합니다. 참조 카운팅 로직을 정확하게 처리하고, ON CONFLICT 절을 사용한 upsert 연산을 구현합니다. 메타데이터 JSON 필드 처리와 created_at 타임스탬프 관리를 포함합니다",
            "status": "done",
            "testStrategy": "각 CRUD 연산 단위 테스트, 참조 카운팅 정확성 검증, 동시 접근 시 데이터 일관성 테스트, 메타데이터 저장/조회 테스트"
          },
          {
            "id": 4,
            "title": "datasets와 transformations 테이블 연산 구현",
            "description": "데이터셋과 변환 기록을 관리하는 테이블들의 연산을 구현합니다",
            "dependencies": [
              3
            ],
            "details": "register_dataset, find_datasets_by_name, get_dataset_versions, register_transformation, get_transformation_chain 등의 메서드를 구현합니다. 외래 키 제약 조건을 준수하고, 데이터셋 버전 관리와 변환 provenance 추적을 위한 쿼리를 최적화합니다",
            "status": "done",
            "testStrategy": "데이터셋 등록/조회 테스트, 버전 관리 동작 확인, 변환 체인 추적 테스트, 외래 키 제약 조건 검증"
          },
          {
            "id": 5,
            "title": "인덱스 최적화와 트랜잭션 처리 구현",
            "description": "쿼리 성능 최적화를 위한 인덱스 설정과 트랜잭션 처리 로직을 구현합니다",
            "dependencies": [
              4
            ],
            "details": "자주 사용되는 쿼리 패턴을 분석하여 적절한 인덱스를 생성하고, 복잡한 연산을 위한 트랜잭션 래퍼 메서드를 구현합니다. EXPLAIN QUERY PLAN을 활용한 쿼리 최적화와 데드락 방지 로직을 포함합니다. 배치 연산과 벌크 삽입 최적화도 구현합니다",
            "status": "done",
            "testStrategy": "쿼리 성능 벤치마크 테스트, 트랜잭션 롤백 시나리오 테스트, 동시성 스트레스 테스트, 인덱스 효과 측정"
          }
        ]
      },
      {
        "id": 8,
        "title": "Nix 통합 및 심링크 팜 생성",
        "description": "Nix derivation과 CAS를 연결하는 심링크 팜 메커니즘 구현",
        "details": "lib/mkDataset.nix 완전 구현:\n```nix\n{ lib, pkgs, ... }:\n{ name, version, manifest, storePath ? null }:\nlet\n  manifestData = if builtins.isPath manifest\n                 then builtins.fromJSON (builtins.readFile manifest)\n                 else manifest;\n  \n  castStore = if storePath != null then storePath\n              else builtins.getEnv \"CAST_STORE\";\n  \n  hashToPath = hash: let\n    stripped = lib.removePrefix \"blake3:\" hash;\n  in \"${castStore}/store/${builtins.substring 0 2 stripped}/\" +\n     \"${builtins.substring 2 2 stripped}/${stripped}\";\n     \nin pkgs.stdenv.mkDerivation {\n  pname = \"cast-dataset-${name}\";\n  inherit version;\n  \n  phases = [ \"installPhase\" ];\n  \n  installPhase = ''\n    mkdir -p $out/data\n    \n    # manifest.json 복사\n    cp ${builtins.toFile \"manifest.json\" (builtins.toJSON manifestData)} $out/manifest.json\n    \n    # 각 파일에 대한 심링크 생성\n    ${lib.concatMapStrings (file: ''\n      target=\"${hashToPath file.hash}\"\n      if [ -e \"$target\" ]; then\n        mkdir -p \"$out/data/$(dirname ${file.path})\"\n        ln -s \"$target\" \"$out/data/${file.path}\"\n      else\n        echo \"Warning: Missing file ${file.hash}\" >&2\n      fi\n    '') manifestData.contents}\n  '';\n  \n  passthru = {\n    inherit manifest;\n    castDatasetName = lib.toUpper (lib.replaceStrings [\"-\"] [\"_\"] name);\n  };\n  \n  setupHook = pkgs.writeText \"setup-hook.sh\" ''\n    export CAST_DATASET_${lib.toUpper (lib.replaceStrings [\"-\"] [\"_\"] name)}=$1/data\n  '';\n}\n```\n\n환경변수 자동 설정, 중첩 디렉토리 구조 처리",
        "testStrategy": "nix build로 derivation 빌드 테스트, 심링크가 올바른 CAS 파일을 가리키는지 확인, 환경변수가 올바르게 설정되는지 테스트",
        "priority": "high",
        "dependencies": [
          3,
          6
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "mkDataset 기본 derivation 구조와 manifest 처리 구현",
            "description": "Nix derivation의 기본 구조를 설정하고 manifest 데이터를 파싱하여 처리하는 로직을 구현합니다.",
            "dependencies": [],
            "details": "lib/mkDataset.nix 파일에서 manifest 파라미터를 받아 파일 경로인 경우 JSON을 읽어 파싱하고, 이미 attrset인 경우 그대로 사용하는 로직을 구현합니다. pkgs.stdenv.mkDerivation을 사용하여 derivation을 생성하고, pname과 version을 설정하며, manifest.json을 $out 디렉토리에 복사하는 installPhase를 작성합니다.",
            "status": "done",
            "testStrategy": "nix eval을 사용하여 manifest 파싱이 올바르게 되는지 확인하고, nix build로 derivation이 생성되는지 테스트합니다."
          },
          {
            "id": 2,
            "title": "CAS 경로 계산과 심링크 생성 로직 구현",
            "description": "BLAKE3 해시를 기반으로 CAS 저장소의 실제 파일 경로를 계산하고 심링크를 생성하는 핵심 로직을 구현합니다.",
            "dependencies": [
              1
            ],
            "details": "hashToPath 함수를 구현하여 blake3: 프리픽스를 제거하고 계층적 디렉토리 구조(hash[:2]/hash[2:4]/full_hash)로 경로를 생성합니다. manifestData.contents의 각 파일에 대해 반복하면서 CAS 저장소의 실제 파일 위치를 찾고 $out/data 디렉토리에 심링크를 생성하는 스크립트를 작성합니다. 파일이 존재하지 않을 경우 경고 메시지를 출력하도록 처리합니다.",
            "status": "done",
            "testStrategy": "테스트 manifest와 dummy CAS 파일들을 생성하여 심링크가 올바른 위치를 가리키는지 확인합니다."
          },
          {
            "id": 3,
            "title": "환경변수 자동 설정과 setupHook 구현",
            "description": "데이터셋이 빌드 입력으로 사용될 때 자동으로 환경변수를 설정하는 setupHook 메커니즘을 구현합니다.",
            "dependencies": [
              2
            ],
            "details": "setupHook 스크립트를 생성하여 CAST_DATASET_<NAME> 형식의 환경변수를 자동으로 export하도록 구현합니다. 데이터셋 이름을 대문자로 변환하고 하이픈을 언더스코어로 치환하는 로직을 작성합니다. passthru 속성에 castDatasetName을 추가하여 다른 derivation에서 참조할 수 있도록 합니다. pkgs.writeText를 사용하여 setup-hook.sh 파일을 생성하고 $out 경로를 환경변수 값으로 설정합니다.",
            "status": "done",
            "testStrategy": "nix develop 환경에서 데이터셋을 buildInputs에 추가하고 환경변수가 올바르게 설정되는지 확인합니다."
          },
          {
            "id": 4,
            "title": "중첩 디렉토리 구조 처리 구현",
            "description": "manifest에 정의된 파일 경로가 중첩된 디렉토리 구조를 가질 때 필요한 디렉토리를 자동으로 생성하는 로직을 구현합니다.",
            "dependencies": [
              2
            ],
            "details": "dirname을 사용하여 파일 경로에서 디렉토리 부분을 추출하고 mkdir -p로 중첩된 디렉토리 구조를 생성합니다. 예를 들어 data/subfolder/file.txt 경로의 경우 $out/data/subfolder 디렉토리를 먼저 생성한 후 심링크를 만듭니다. lib.concatMapStrings를 사용하여 모든 파일에 대해 이 작업을 수행하는 bash 스크립트를 생성합니다.",
            "status": "done",
            "testStrategy": "깊은 중첩 구조를 가진 manifest로 테스트하여 모든 디렉토리가 올바르게 생성되는지 확인합니다."
          },
          {
            "id": 5,
            "title": "통합 테스트와 에러 처리 구현",
            "description": "전체 mkDataset 함수의 통합 테스트를 작성하고 다양한 에러 상황에 대한 처리를 구현합니다.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "CAST_STORE 환경변수가 설정되지 않았거나 storePath가 제공되지 않은 경우의 에러 처리를 구현합니다. manifest 파일이 없거나 잘못된 JSON 형식일 때의 에러 메시지를 개선합니다. CAS 파일이 존재하지 않을 때의 경고 메시지와 함께 빌드는 계속 진행되도록 처리합니다. examples/simple-dataset 디렉토리에 실제 사용 예제를 작성하고 nix flake check로 검증합니다.",
            "status": "done",
            "testStrategy": "다양한 에러 시나리오(잘못된 manifest, 없는 CAS 파일, 환경변수 미설정 등)를 테스트하고 적절한 에러 메시지가 출력되는지 확인합니다."
          }
        ]
      },
      {
        "id": 9,
        "title": "변환 파이프라인 시스템 구현",
        "description": "데이터 변환을 위한 Nix 함수와 캐싱 메커니즘 구현",
        "details": "lib/transform.nix 구현:\n```nix\n{ lib, pkgs, cast-cli }:\n{ name, src, builder, outputs ? [\"out\"] }:\nlet\n  srcManifest = src.manifest or (builtins.fromJSON (builtins.readFile \"${src}/manifest.json\"));\nin pkgs.stdenv.mkDerivation {\n  pname = \"cast-transform-${name}\";\n  version = srcManifest.dataset.version or \"unknown\";\n  \n  inherit src builder;\n  \n  buildInputs = [ cast-cli ];\n  \n  phases = [ \"unpackPhase\" \"buildPhase\" \"installPhase\" ];\n  \n  unpackPhase = ''\n    # src 데이터를 작업 디렉토리로 복사/링크\n    cp -r ${src}/data/* .\n  '';\n  \n  buildPhase = ''\n    export CAST_OUTPUT=$PWD/output\n    mkdir -p $CAST_OUTPUT\n    \n    # 사용자 정의 builder 실행\n    ${builder}\n  '';\n  \n  installPhase = ''\n    # 출력을 CAS에 저장하고 manifest 생성\n    manifest=$(cast-cli transform \\\n      --input-manifest ${src}/manifest.json \\\n      --output-dir $CAST_OUTPUT \\\n      --transform-type \"${name}\")\n    \n    mkdir -p $out\n    echo \"$manifest\" > $out/manifest.json\n    \n    # 심링크 팜 생성\n    for file in $(find $CAST_OUTPUT -type f); do\n      rel_path=''${file#$CAST_OUTPUT/}\n      hash=$(cast-cli put \"$file\")\n      mkdir -p \"$out/data/$(dirname $rel_path)\"\n      ln -s \"$(cast-cli get-path $hash)\" \"$out/data/$rel_path\"\n    done\n  '';\n  \n  passthru = {\n    inherit srcManifest;\n    transformationType = name;\n  };\n}\n```\n\ncast-cli transform 명령어 구현, 변환 캐싱, provenance 추적",
        "testStrategy": "간단한 변환 (파일 복사) 테스트, 복잡한 변환 (압축 해제, 포맷 변환) 테스트, 캐싱이 작동하는지 확인, provenance 체인 검증",
        "priority": "low",
        "dependencies": [
          8
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "transform.nix 기본 구조와 builder 통합 구현",
            "description": "Nix derivation 구조를 생성하고 사용자 정의 builder를 통합하는 기본 transform.nix 파일 구현",
            "dependencies": [],
            "details": "lib/transform.nix 파일에 mkDerivation 기반 변환 파이프라인 구조를 구현합니다. src에서 manifest를 읽고, builder를 실행하며, outputs를 처리하는 3단계 phases (unpack, build, install)를 정의합니다. passthru로 srcManifest와 transformationType 메타데이터를 전달합니다.",
            "status": "done",
            "testStrategy": "간단한 파일 복사 builder로 Nix derivation이 정상 빌드되는지 테스트, nix eval로 함수 시그니처 검증"
          },
          {
            "id": 2,
            "title": "CAST_OUTPUT 환경변수 처리와 디렉토리 관리",
            "description": "변환 중 출력을 관리할 CAST_OUTPUT 환경변수 설정과 임시 디렉토리 관리 로직 구현",
            "dependencies": [
              1
            ],
            "details": "buildPhase에서 CAST_OUTPUT 환경변수를 설정하고 출력 디렉토리를 생성합니다. builder 스크립트가 이 디렉토리에 변환 결과를 쓸 수 있도록 export하고, 각 변환 단계에서 필요한 작업 디렉토리를 관리합니다. 다중 출력 지원을 위한 디렉토리 구조도 준비합니다.",
            "status": "done",
            "testStrategy": "환경변수가 올바르게 설정되는지 확인, 임시 디렉토리 생성과 정리 테스트"
          },
          {
            "id": 3,
            "title": "cast-cli transform 명령어 Rust 구현",
            "description": "Rust CLI에 transform 서브커맨드를 추가하고 변환 작업을 처리하는 로직 구현",
            "dependencies": [
              2
            ],
            "details": "packages/cast-cli/src/commands/transform.rs를 생성하여 --input-manifest, --output-dir, --transform-type 옵션을 처리합니다. 입력 manifest를 파싱하고, 출력 파일들을 해싱하며, 변환 정보를 포함한 새 manifest를 생성합니다. SQLite에 변환 기록을 저장하는 로직도 포함합니다.",
            "status": "done",
            "testStrategy": "단위 테스트로 manifest 파싱과 생성 검증, 통합 테스트로 실제 파일 변환 테스트"
          },
          {
            "id": 4,
            "title": "변환 결과 CAS 저장과 manifest 생성",
            "description": "변환된 파일들을 CAS에 저장하고 출력 manifest를 생성하는 installPhase 구현",
            "dependencies": [
              3
            ],
            "details": "installPhase에서 cast-cli transform 명령을 호출하여 CAST_OUTPUT의 파일들을 처리합니다. 각 출력 파일을 cast-cli put으로 CAS에 저장하고, 해시 값으로 심링크를 생성합니다. transformations 필드에 변환 이력을 기록한 manifest.json을 $out에 저장합니다.",
            "status": "done",
            "testStrategy": "CAS에 파일이 올바르게 저장되는지 확인, 생성된 심링크가 유효한지 테스트, manifest의 transformations 필드 검증"
          },
          {
            "id": 5,
            "title": "변환 캐싱과 provenance 추적 구현",
            "description": "동일한 입력에 대한 변환 결과를 캐싱하고 변환 체인을 추적하는 메커니즘 구현",
            "dependencies": [
              4
            ],
            "details": "SQLite의 transformations 테이블에 입력 해시, 변환 타입, 파라미터, 출력 해시를 저장합니다. cast-cli transform에서 캐시를 먼저 확인하여 동일한 변환은 건너뜁니다. manifest의 transformations 배열에 전체 변환 체인을 기록하여 데이터 출처를 추적 가능하게 합니다.\n<info added on 2025-11-18T01:58:38.681Z>\nProvenance tracking이 이미 구현되어 있습니다 - transform 명령은 기존 transformations를 유지하면서 새로운 변환을 체인에 추가합니다. 캐싱의 경우, Nix의 content-addressing이 derivation 수준 캐싱을 자동으로 제공합니다. 입력이 변경되지 않으면 Nix가 캐시된 결과를 재사용합니다. 이는 Nix 자체에서 처리되므로 SQLite 수준 캐싱보다 더 효율적입니다.\n</info added on 2025-11-18T01:58:38.681Z>",
            "status": "done",
            "testStrategy": "동일한 변환을 두 번 실행했을 때 캐시가 사용되는지 확인, provenance 체인이 올바르게 기록되는지 검증"
          },
          {
            "id": 6,
            "title": "다양한 변환 시나리오 종합 테스트",
            "description": "파일 복사, 압축 해제, 포맷 변환 등 다양한 실제 변환 시나리오를 테스트",
            "dependencies": [
              5
            ],
            "details": "examples/transformation/에 여러 변환 예제를 구현합니다. tar.gz 해제, CSV to JSON 변환, 이미지 리사이징 등 실제 사용 케이스를 테스트합니다. 각 예제에서 캐싱이 작동하고, provenance가 기록되며, 심링크 팜이 올바르게 생성되는지 확인합니다.",
            "status": "done",
            "testStrategy": "각 변환 예제가 nix build로 성공하는지 테스트, 변환 결과 파일의 내용 검증, 캐시 히트율 측정"
          }
        ]
      },
      {
        "id": 10,
        "title": "예제 및 문서화 완성",
        "description": "사용 예제, README, API 문서 작성으로 프로젝트 완성",
        "details": "examples/ 디렉토리 구성:\n\nexamples/simple-dataset/flake.nix:\n```nix\n{\n  inputs = {\n    nixpkgs.url = \"github:NixOS/nixpkgs/nixos-unstable\";\n    cast.url = \"path:../..\";\n  };\n  \n  outputs = { self, nixpkgs, cast }: {\n    packages.x86_64-linux.example-dataset = cast.lib.mkDataset {\n      name = \"test-data\";\n      version = \"1.0.0\";\n      manifest = ./manifest.json;\n    };\n  };\n}\n```\n\nexamples/transformation/flake.nix:\n```nix\n{\n  inputs = {\n    nixpkgs.url = \"github:NixOS/nixpkgs/nixos-unstable\";\n    cast.url = \"path:../..\";\n  };\n  \n  outputs = { self, nixpkgs, cast }:\n  let\n    pkgs = nixpkgs.legacyPackages.x86_64-linux;\n    \n    # NCBI 데이터베이스 다운로드\n    ncbiNr = cast.lib.fetchDatabase {\n      name = \"ncbi-nr\";\n      url = \"ftp://ftp.ncbi.nlm.nih.gov/blast/db/nr.tar.gz\";\n      extract = true;\n    };\n    \n    # MMseqs 데이터베이스로 변환\n    ncbiMmseqs = cast.lib.transform {\n      name = \"ncbi-to-mmseqs\";\n      src = ncbiNr;\n      builder = pkgs.writeShellScript \"convert\" ''\n        ${pkgs.mmseqs2}/bin/mmseqs createdb \\\n          ${ncbiNr}/data/nr.fasta \\\n          $CAST_OUTPUT/nr_mmseqs\n        \n        ${pkgs.mmseqs2}/bin/mmseqs createindex \\\n          $CAST_OUTPUT/nr_mmseqs \\\n          $CAST_OUTPUT/tmp\n      '';\n    };\n  in {\n    packages.x86_64-linux = {\n      ncbi-nr = ncbiNr;\n      ncbi-mmseqs = ncbiMmseqs;\n    };\n    \n    devShells.x86_64-linux.default = pkgs.mkShell {\n      buildInputs = [ pkgs.mmseqs2 ncbiMmseqs ];\n      shellHook = ''\n        echo \"NCBI MMseqs database available at: $CAST_DATASET_NCBI_TO_MMSEQS\"\n      '';\n    };\n  };\n}\n```\n\nREADME.md:\n- 설치 가이드\n- 빠른 시작 튜토리얼\n- API 레퍼런스\n- 아키텍처 설명\n- 기여 가이드라인\n\ncast-cli --help 출력 개선, man 페이지 생성",
        "testStrategy": "모든 예제가 nix build로 빌드되는지 테스트, 문서의 코드 스니펫이 실행 가능한지 확인, README의 설치 가이드를 따라 실제 설치 테스트",
        "priority": "low",
        "dependencies": [
          8,
          9
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "기본 데이터셋 예제(simple-dataset) 구현",
            "description": "간단한 테스트 데이터셋을 생성하고 CAST로 등록하는 기본 예제를 구현합니다.",
            "dependencies": [],
            "details": "examples/simple-dataset/ 디렉토리에 flake.nix, manifest.json, 샘플 데이터 파일들을 생성합니다. manifest.json에는 테스트 데이터의 메타데이터와 BLAKE3 해시를 포함하고, flake.nix에서는 cast.lib.mkDataset을 사용해 데이터셋을 등록하는 예제를 구현합니다. README.md를 추가하여 예제 사용법을 설명합니다.",
            "status": "done",
            "testStrategy": "nix build .#example-dataset으로 빌드 테스트, 생성된 심링크 팜이 올바른지 확인, manifest 검증"
          },
          {
            "id": 2,
            "title": "변환 파이프라인 및 레지스트리 예제 구현",
            "description": "실제 데이터베이스를 다운로드하고 변환하는 고급 예제와 다중 버전 관리 레지스트리 예제를 구현합니다.",
            "dependencies": [
              1
            ],
            "details": "examples/transformation/에 NCBI 데이터베이스를 MMseqs 포맷으로 변환하는 예제를 구현합니다. examples/registry/에 여러 버전의 데이터베이스를 관리하는 레지스트리 패턴을 보여주는 예제를 추가합니다. 각 예제에 대한 상세한 README.md와 실행 가능한 스크립트를 포함합니다.",
            "status": "done",
            "testStrategy": "각 예제의 nix build 성공 여부, 변환 결과물 검증, 레지스트리 버전 관리 테스트"
          },
          {
            "id": 3,
            "title": "포괄적인 README.md 및 API 문서 작성",
            "description": "프로젝트 소개, 설치 가이드, 빠른 시작 튜토리얼, 전체 API 레퍼런스를 포함한 메인 README.md를 작성합니다.",
            "dependencies": [
              1,
              2
            ],
            "details": "프로젝트 루트에 README.md를 작성하여 CAST의 목적과 아키텍처를 설명합니다. Nix flake를 통한 설치 방법, cast-cli 바이너리 설치, 환경변수 설정 등을 포함한 상세한 설치 가이드를 제공합니다. 각 cast.lib.* 함수의 파라미터, 반환값, 사용 예제를 포함한 완전한 API 레퍼런스를 작성합니다. docs/ 디렉토리에 아키텍처, 디자인 결정, 기여 가이드라인 등의 추가 문서를 작성합니다.",
            "status": "pending",
            "testStrategy": "문서의 모든 코드 스니펫이 실행 가능한지 확인, 설치 가이드를 따라 실제 설치 테스트"
          },
          {
            "id": 4,
            "title": "CLI 도움말 개선 및 man 페이지 생성",
            "description": "cast-cli의 --help 출력을 개선하고 포맷된 man 페이지를 생성합니다.",
            "dependencies": [
              3
            ],
            "details": "Rust clap 라이브러리의 도움말 템플릿을 커스터마이즈하여 더 상세하고 사용자 친화적인 도움말 메시지를 제공합니다. 각 서브커맨드에 대한 예제와 일반적인 사용 패턴을 포함합니다. clap_mangen을 사용하여 man 페이지를 자동 생성하고 Nix derivation에 포함시킵니다. cast(1), cast-put(1), cast-get(1) 등의 섹션별 man 페이지를 제공합니다.",
            "status": "pending",
            "testStrategy": "cast-cli --help의 가독성 확인, man cast 명령 작동 테스트, 모든 서브커맨드 도움말 검증"
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-11-17T15:10:33.104Z",
      "updated": "2025-11-18T02:26:08.024Z",
      "description": "Tasks for master context"
    }
  }
}