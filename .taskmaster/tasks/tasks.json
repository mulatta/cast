{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "프로젝트 구조 스켈레톤 생성",
        "description": "CAST 프로젝트의 전체 디렉토리 구조와 초기 설정 파일들을 생성",
        "details": "다음 구조를 생성합니다:\n- flake.nix: inputs에 nixpkgs, rust-overlay 포함, outputs에 lib, packages, devShells 정의\n- lib/: default.nix에서 모든 라이브러리 함수 export\n- lib/mkDataset.nix: 스텁 함수 { name, version, manifest, storePath ? null }: derivation\n- lib/fetchDatabase.nix: 스텁 함수 { name, url, hash ? null, extract ? false, metadata ? {} }: manifest\n- lib/transform.nix: 스텁 함수 { name, src, builder, outputs ? [\"out\"] }: derivation\n- lib/symlinkSubset.nix: 스텁 함수 { name, paths }: derivation\n- lib/manifest.nix: readManifest, hashToPath, manifestToEnv 유틸리티 함수\n- lib/types.nix: Nix 타입 정의 (manifestType, datasetType 등)\n- packages/cast-cli/: Cargo.toml, src/main.rs 초기 구조\n- schemas/: manifest-v1.json, config-v1.json 플레이스홀더\n- examples/: simple-dataset/, transformation/, registry/ 디렉토리\n- dev/: formatter.nix (alejandra 사용), shell.nix (rust-analyzer, cargo-watch 포함)",
        "testStrategy": "nix flake check가 성공적으로 실행되는지 확인, nix develop로 개발 셸 진입 가능 여부 테스트, 모든 디렉토리가 생성되었는지 확인",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "flake.nix와 기본 Nix 설정 파일 생성",
            "description": "프로젝트 루트에 flake.nix 파일을 생성하고 nixpkgs, rust-overlay를 inputs로 설정하며, outputs에 lib, packages, devShells를 정의합니다.",
            "dependencies": [],
            "details": "flake.nix 파일을 생성하여 inputs에 nixpkgs와 rust-overlay를 추가하고, outputs 섹션에서 lib (Nix 라이브러리 함수들), packages (cast-cli), devShells (개발 환경)를 정의합니다. 또한 flake.lock 파일이 생성되도록 nix flake update를 실행하고, .gitignore에 필요한 항목들을 추가합니다.",
            "status": "pending",
            "testStrategy": "nix flake check 명령이 오류 없이 실행되는지 확인하고, nix flake show로 모든 outputs가 올바르게 표시되는지 검증합니다."
          },
          {
            "id": 2,
            "title": "lib/ 디렉토리와 모든 Nix 라이브러리 스텁 파일 생성",
            "description": "lib 디렉토리를 생성하고 mkDataset.nix, fetchDatabase.nix, transform.nix, symlinkSubset.nix, manifest.nix, types.nix 파일들을 스텁 함수로 구현합니다.",
            "dependencies": [
              1
            ],
            "details": "lib/default.nix를 생성하여 모든 라이브러리 함수를 export하고, 각 개별 파일(mkDataset.nix, fetchDatabase.nix, transform.nix, symlinkSubset.nix, manifest.nix, types.nix)에 스텁 함수를 구현합니다. 각 함수는 올바른 시그니처를 가지되 실제 구현은 플레이스홀더로 남겨둡니다. types.nix에는 manifestType, datasetType 등의 Nix 타입 정의를 추가합니다.",
            "status": "pending",
            "testStrategy": "nix eval .#lib로 라이브러리 함수들이 올바르게 export되는지 확인하고, 각 함수가 올바른 인자를 받아들이는지 테스트합니다."
          },
          {
            "id": 3,
            "title": "Rust CLI 프로젝트 초기 구조 설정",
            "description": "packages/cast-cli 디렉토리에 Cargo.toml과 기본 Rust 프로젝트 구조를 설정하고 초기 main.rs 파일을 생성합니다.",
            "dependencies": [
              1
            ],
            "details": "packages/cast-cli/Cargo.toml 파일을 생성하여 프로젝트 메타데이터와 필요한 의존성(blake3, sqlx, tokio, anyhow, clap 등)을 정의합니다. src/main.rs에 기본 CLI 구조를 구현하고, src/storage/mod.rs, src/hash.rs, src/manifest.rs, src/db.rs 파일들을 플레이스홀더로 생성합니다. 또한 README.md 파일을 추가하여 CLI 도구의 목적과 사용법을 간단히 문서화합니다.",
            "status": "pending",
            "testStrategy": "cargo build --manifest-path packages/cast-cli/Cargo.toml 명령이 성공적으로 실행되는지 확인하고, cargo test로 기본 테스트가 통과하는지 검증합니다."
          },
          {
            "id": 4,
            "title": "스키마와 예제 디렉토리 구조 생성",
            "description": "schemas 디렉토리에 JSON 스키마 파일들을 생성하고, examples 디렉토리에 사용 예제를 위한 하위 디렉토리들을 구성합니다.",
            "dependencies": [],
            "details": "schemas/manifest-v1.json과 schemas/config-v1.json 파일을 플레이스홀더로 생성하여 기본 JSON 스키마 구조를 정의합니다. examples 디렉토리 아래에 simple-dataset/, transformation/, registry/ 하위 디렉토리를 생성하고 각각에 빈 README.md 파일을 추가합니다. 추후 구현될 예제들의 기반이 될 디렉토리 구조를 미리 준비합니다.",
            "status": "pending",
            "testStrategy": "모든 디렉토리가 올바르게 생성되었는지 find 명령으로 확인하고, tree 명령으로 전체 구조를 검증합니다."
          },
          {
            "id": 5,
            "title": "개발 환경 설정 파일 작성",
            "description": "dev 디렉토리에 formatter.nix와 shell.nix 파일을 생성하여 개발 환경을 구성합니다.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "dev/formatter.nix 파일을 생성하여 alejandra를 코드 포매터로 설정하고, dev/shell.nix에서 rust-analyzer, cargo-watch, clippy, rustfmt 등 Rust 개발에 필요한 도구들을 포함하는 개발 셸을 정의합니다. 또한 환경 변수 설정과 셸 hook을 추가하여 개발자가 nix develop 명령으로 즉시 개발을 시작할 수 있도록 구성합니다.",
            "status": "pending",
            "testStrategy": "nix develop 명령으로 개발 셸에 진입할 수 있는지 확인하고, 셸 내에서 cargo, rust-analyzer 등의 도구가 사용 가능한지 검증합니다."
          }
        ]
      },
      {
        "id": 2,
        "title": "Manifest JSON 스키마 정의",
        "description": "데이터셋 메타데이터를 위한 JSON 스키마 v1 정의 및 문서화",
        "details": "schemas/manifest-v1.json 파일 생성:\n```json\n{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"type\": \"object\",\n  \"required\": [\"schema_version\", \"dataset\", \"source\", \"contents\"],\n  \"properties\": {\n    \"schema_version\": { \"type\": \"string\", \"const\": \"1.0\" },\n    \"dataset\": {\n      \"type\": \"object\",\n      \"required\": [\"name\", \"version\"],\n      \"properties\": {\n        \"name\": { \"type\": \"string\" },\n        \"version\": { \"type\": \"string\" },\n        \"description\": { \"type\": \"string\" }\n      }\n    },\n    \"source\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"url\": { \"type\": \"string\", \"format\": \"uri\" },\n        \"download_date\": { \"type\": \"string\", \"format\": \"date-time\" },\n        \"server_mtime\": { \"type\": \"string\", \"format\": \"date-time\" },\n        \"archive_hash\": { \"type\": \"string\", \"pattern\": \"^blake3:[a-f0-9]{64}$\" }\n      }\n    },\n    \"contents\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"object\",\n        \"required\": [\"path\", \"hash\", \"size\"],\n        \"properties\": {\n          \"path\": { \"type\": \"string\" },\n          \"hash\": { \"type\": \"string\", \"pattern\": \"^blake3:[a-f0-9]{64}$\" },\n          \"size\": { \"type\": \"integer\", \"minimum\": 0 },\n          \"executable\": { \"type\": \"boolean\", \"default\": false }\n        }\n      }\n    },\n    \"transformations\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"object\",\n        \"required\": [\"type\", \"from\"],\n        \"properties\": {\n          \"type\": { \"type\": \"string\" },\n          \"from\": { \"type\": \"string\" },\n          \"params\": { \"type\": \"object\" }\n        }\n      }\n    }\n  }\n}\n```\nJSON Schema 검증 도구 (ajv-cli) 통합도 포함",
        "testStrategy": "ajv-cli를 사용한 스키마 검증 테스트, 예제 매니페스트 파일들이 스키마를 통과하는지 확인, 잘못된 매니페스트가 실패하는지 테스트",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Nix 라이브러리 API 구현",
        "description": "cast.lib.* 네임스페이스의 핵심 Nix 함수들을 구현",
        "details": "lib/default.nix에서 모든 함수 export:\n```nix\n{ lib, pkgs, ... }:\nrec {\n  mkDataset = import ./mkDataset.nix { inherit lib pkgs; };\n  fetchDatabase = import ./fetchDatabase.nix { inherit lib pkgs mkDataset; };\n  transform = import ./transform.nix { inherit lib pkgs; };\n  symlinkSubset = import ./symlinkSubset.nix { inherit lib pkgs; };\n  manifest = import ./manifest.nix { inherit lib; };\n  types = import ./types.nix { inherit lib; };\n}\n```\n\n각 함수 구현:\n- mkDataset: manifest를 읽고 심링크 팜을 생성하는 derivation 빌드\n- fetchDatabase: curl/wget으로 다운로드 후 cast-cli put 호출\n- transform: CAST_OUTPUT 환경변수 설정 후 builder 실행\n- symlinkSubset: 선택적 심링크 생성\n- manifest.readManifest: JSON 파싱\n- manifest.hashToPath: 해시를 CAS 경로로 변환\n- manifest.manifestToEnv: 환경변수 생성",
        "testStrategy": "각 함수에 대한 Nix 평가 테스트, flake.nix checks 속성에 테스트 추가, 예제 사용 케이스로 통합 테스트",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "lib/default.nix 파일 생성 및 기본 export 구조 설정",
            "description": "Nix 라이브러리의 진입점인 lib/default.nix 파일을 생성하고, 모든 하위 모듈을 import하여 export하는 기본 구조를 구현합니다.",
            "dependencies": [],
            "details": "lib/default.nix 파일을 생성하여 mkDataset, fetchDatabase, transform, symlinkSubset, manifest, types 모듈을 import하고 rec 속성셋으로 export합니다. 각 모듈 파일의 스켈레톤도 함께 생성하여 후속 작업이 가능하도록 합니다.",
            "status": "pending",
            "testStrategy": "nix eval로 라이브러리가 올바르게 로드되는지 확인, 각 함수가 접근 가능한지 테스트"
          },
          {
            "id": 2,
            "title": "mkDataset 함수 구현 - manifest 읽기 및 심링크 팜 생성",
            "description": "manifest.json을 읽어서 CAS 저장소의 실제 파일들을 가리키는 심링크 팜을 생성하는 Nix derivation을 빌드하는 mkDataset 함수를 구현합니다.",
            "dependencies": [
              1
            ],
            "details": "lib/mkDataset.nix에서 manifest를 파싱하여 각 파일의 BLAKE3 해시를 CAS 경로로 변환하고, /nix/store에 심링크 팜을 생성하는 derivation을 구현합니다. CAST_STORE 환경변수와 storePath 파라미터를 지원하며, 환경변수 export 기능도 포함합니다.",
            "status": "pending",
            "testStrategy": "테스트 manifest로 derivation 빌드 확인, 생성된 심링크가 올바른 CAS 경로를 가리키는지 검증"
          },
          {
            "id": 3,
            "title": "fetchDatabase 함수 구현 - 데이터베이스 다운로드 및 CAS 등록",
            "description": "원격 URL에서 데이터베이스를 다운로드하고 cast-cli를 통해 CAS에 저장한 후 manifest를 생성하는 fetchDatabase 함수를 구현합니다.",
            "dependencies": [
              2
            ],
            "details": "lib/fetchDatabase.nix에서 curl/wget을 사용하여 데이터를 다운로드하고, cast-cli put 명령으로 CAS에 저장합니다. 아카이브 자동 추출 옵션을 지원하며, 다운로드 메타데이터(URL, 시간, 서버 mtime)를 manifest에 포함시킵니다.",
            "status": "pending",
            "testStrategy": "mock URL로 다운로드 테스트, cast-cli 호출 검증, 생성된 manifest 구조 확인"
          },
          {
            "id": 4,
            "title": "transform 함수 구현 - 데이터 변환 파이프라인",
            "description": "입력 데이터셋을 받아 변환 작업을 수행하고 결과를 CAS에 저장하는 transform 함수를 구현합니다.",
            "dependencies": [
              2
            ],
            "details": "lib/transform.nix에서 CAST_OUTPUT 환경변수를 설정하고 사용자 정의 builder 스크립트를 실행합니다. 변환 결과는 cast-cli를 통해 CAS에 저장되며, provenance 체인이 manifest에 기록됩니다. 캐싱 메커니즘도 구현하여 동일한 변환은 재실행하지 않도록 합니다.",
            "status": "pending",
            "testStrategy": "간단한 변환(파일 복사) 테스트, 복잡한 변환(압축 해제) 테스트, 캐싱 작동 확인"
          },
          {
            "id": 5,
            "title": "symlinkSubset과 manifest 유틸리티 함수 구현",
            "description": "데이터셋의 부분 집합을 위한 심링크를 생성하는 symlinkSubset과 manifest 관련 유틸리티 함수들을 구현합니다.",
            "dependencies": [
              1
            ],
            "details": "lib/symlinkSubset.nix에서 지정된 경로들만 포함하는 선택적 심링크 팜을 생성합니다. lib/manifest.nix에서 readManifest(JSON 파싱), hashToPath(해시→CAS 경로 변환), manifestToEnv(환경변수 생성) 유틸리티 함수를 구현합니다.",
            "status": "pending",
            "testStrategy": "부분 집합 생성 테스트, manifest 파싱 정확성 검증, 환경변수 생성 확인"
          },
          {
            "id": 6,
            "title": "types.nix 타입 정의 및 flake.nix checks 테스트 작성",
            "description": "Nix 라이브러리 함수들의 입력 파라미터 타입을 정의하고, flake.nix의 checks 속성에 통합 테스트를 추가합니다.",
            "dependencies": [
              2,
              3,
              4,
              5
            ],
            "details": "lib/types.nix에서 lib.types를 사용하여 manifest, dataset, transformation 등의 타입을 정의합니다. flake.nix의 checks 속성에 각 라이브러리 함수의 평가 테스트와 통합 테스트를 추가하여 nix flake check로 모든 테스트를 실행할 수 있도록 합니다.",
            "status": "pending",
            "testStrategy": "타입 체크 테스트, 각 함수의 파라미터 검증, 통합 시나리오 테스트, CI에서 자동 실행 가능성 확인"
          }
        ]
      },
      {
        "id": 4,
        "title": "Rust CLI 기본 구조 설정",
        "description": "cast-cli Rust 프로젝트의 기초를 구축하고 명령어 파싱 구현",
        "details": "packages/cast-cli/Cargo.toml:\n```toml\n[package]\nname = \"cast-cli\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[dependencies]\nblake3 = \"1.5\"\ntokio = { version = \"1.40\", features = [\"full\"] }\nsqlx = { version = \"0.8\", features = [\"runtime-tokio\", \"sqlite\"] }\nclap = { version = \"4.5\", features = [\"derive\"] }\nanyhow = \"1.0\"\nthiserror = \"2.0\"\ntracing = \"0.1\"\ntracing-subscriber = { version = \"0.3\", features = [\"env-filter\"] }\nserde = { version = \"1.0\", features = [\"derive\"] }\nserde_json = \"1.0\"\n```\n\nsrc/main.rs:\n```rust\nuse clap::{Parser, Subcommand};\nuse anyhow::Result;\n\n#[derive(Parser)]\n#[command(name = \"cast\")]\n#[command(about = \"Content-Addressed Storage Tool\")]\nstruct Cli {\n    #[command(subcommand)]\n    command: Commands,\n}\n\n#[derive(Subcommand)]\nenum Commands {\n    Put { file: String },\n    Get { hash: String },\n    Fetch { url: String },\n    Transform { manifest: String },\n    Gc { #[arg(long)] dry_run: bool },\n}\n\n#[tokio::main]\nasync fn main() -> Result<()> {\n    tracing_subscriber::fmt::init();\n    let cli = Cli::parse();\n    // 명령어 처리\n    Ok(())\n}\n```\n\n모듈 구조:\n- src/storage/mod.rs: StorageBackend trait 정의\n- src/storage/local.rs: LocalStorage 구현\n- src/hash.rs: BLAKE3 해싱 함수\n- src/manifest.rs: Manifest 타입 및 직렬화\n- src/db.rs: SQLite 연산",
        "testStrategy": "cargo test로 유닛 테스트, cargo clippy로 lint 검사, 각 명령어가 올바른 인자로 파싱되는지 테스트",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "BLAKE3 해싱 구현",
        "description": "효율적인 BLAKE3 컨텐츠 해싱을 Rust로 구현",
        "details": "src/hash.rs 구현:\n```rust\nuse blake3::{Hasher, Hash};\nuse std::fs::File;\nuse std::io::{self, Read, BufReader};\nuse std::path::Path;\nuse anyhow::Result;\n\npub struct Blake3Hash(Hash);\n\nimpl Blake3Hash {\n    pub fn from_file<P: AsRef<Path>>(path: P) -> Result<Self> {\n        let file = File::open(path)?;\n        let mut reader = BufReader::with_capacity(1024 * 1024, file);\n        let mut hasher = Hasher::new();\n        let mut buffer = [0u8; 16384];\n        \n        loop {\n            let bytes_read = reader.read(&mut buffer)?;\n            if bytes_read == 0 { break; }\n            hasher.update(&buffer[..bytes_read]);\n        }\n        \n        Ok(Blake3Hash(hasher.finalize()))\n    }\n    \n    pub fn from_bytes(data: &[u8]) -> Self {\n        Blake3Hash(blake3::hash(data))\n    }\n    \n    pub fn to_string(&self) -> String {\n        format!(\"blake3:{}\", self.0.to_hex())\n    }\n    \n    pub fn verify(&self, other: &str) -> bool {\n        other == self.to_string()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    \n    #[test]\n    fn test_hash_bytes() {\n        let data = b\"hello world\";\n        let hash = Blake3Hash::from_bytes(data);\n        assert!(hash.to_string().starts_with(\"blake3:\"));\n    }\n}\n```\n\n대용량 파일을 위한 스트리밍 처리, 병렬 해싱 지원 추가",
        "testStrategy": "알려진 입력에 대한 해시 값 검증, 대용량 파일 해싱 성능 테스트, 동일 파일에 대한 일관된 해시 생성 확인",
        "priority": "medium",
        "dependencies": [
          4
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "로컬 스토리지 백엔드 구현",
        "description": "계층적 디렉토리 구조를 가진 로컬 파일시스템 스토리지 구현",
        "details": "src/storage/backend.rs:\n```rust\nuse async_trait::async_trait;\nuse std::path::PathBuf;\nuse anyhow::Result;\nuse crate::hash::Blake3Hash;\nuse crate::manifest::Manifest;\n\n#[async_trait]\npub trait StorageBackend: Send + Sync {\n    async fn put(&self, data: impl Read + Send) -> Result<Blake3Hash>;\n    async fn get(&self, hash: &Blake3Hash) -> Result<PathBuf>;\n    async fn exists(&self, hash: &Blake3Hash) -> bool;\n    async fn delete(&self, hash: &Blake3Hash) -> Result<()>;\n    async fn register_dataset(&self, manifest: &Manifest) -> Result<()>;\n}\n```\n\nsrc/storage/local.rs:\n```rust\nuse super::StorageBackend;\nuse std::path::{Path, PathBuf};\nuse tokio::fs;\nuse tokio::io::AsyncWriteExt;\n\npub struct LocalStorage {\n    root: PathBuf,\n}\n\nimpl LocalStorage {\n    pub fn new(root: impl AsRef<Path>) -> Self {\n        LocalStorage { root: root.as_ref().to_path_buf() }\n    }\n    \n    fn hash_to_path(&self, hash: &Blake3Hash) -> PathBuf {\n        let hex = hash.to_string().strip_prefix(\"blake3:\").unwrap();\n        self.root\n            .join(\"store\")\n            .join(&hex[..2])\n            .join(&hex[2..4])\n            .join(hex)\n    }\n}\n\n#[async_trait]\nimpl StorageBackend for LocalStorage {\n    async fn put(&self, mut data: impl Read + Send) -> Result<Blake3Hash> {\n        let mut buffer = Vec::new();\n        data.read_to_end(&mut buffer)?;\n        let hash = Blake3Hash::from_bytes(&buffer);\n        let path = self.hash_to_path(&hash);\n        \n        fs::create_dir_all(path.parent().unwrap()).await?;\n        let mut file = fs::File::create(path).await?;\n        file.write_all(&buffer).await?;\n        \n        Ok(hash)\n    }\n    // 나머지 메서드 구현...\n}\n```\n\n설정 로딩: CAST_STORE 환경변수 > config.toml > ~/.cache/cast",
        "testStrategy": "임시 디렉토리에서 put/get 연산 테스트, 해시 충돌 처리 테스트, 동시 접근 테스트, 참조 카운팅 테스트",
        "priority": "medium",
        "dependencies": [
          5
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "SQLite 메타데이터 데이터베이스 구현",
        "description": "객체, 데이터셋, 변환 추적을 위한 SQLite 스키마 및 연산 구현",
        "details": "src/db.rs 구현:\n```rust\nuse sqlx::{SqlitePool, migrate::MigrateDatabase};\nuse anyhow::Result;\n\npub struct MetadataDb {\n    pool: SqlitePool,\n}\n\nimpl MetadataDb {\n    pub async fn new(db_path: &str) -> Result<Self> {\n        if !sqlx::Sqlite::database_exists(db_path).await? {\n            sqlx::Sqlite::create_database(db_path).await?;\n        }\n        \n        let pool = SqlitePool::connect(db_path).await?;\n        \n        // 스키마 생성\n        sqlx::query(\n            r#\"\n            CREATE TABLE IF NOT EXISTS objects (\n                hash TEXT PRIMARY KEY,\n                size INTEGER NOT NULL,\n                refs INTEGER DEFAULT 1,\n                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n                metadata TEXT\n            );\n            \n            CREATE TABLE IF NOT EXISTS datasets (\n                id INTEGER PRIMARY KEY AUTOINCREMENT,\n                name TEXT NOT NULL,\n                version TEXT NOT NULL,\n                manifest_hash TEXT NOT NULL,\n                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n                UNIQUE(name, version),\n                FOREIGN KEY (manifest_hash) REFERENCES objects(hash)\n            );\n            \n            CREATE TABLE IF NOT EXISTS transformations (\n                id INTEGER PRIMARY KEY AUTOINCREMENT,\n                input_hash TEXT NOT NULL,\n                output_hash TEXT NOT NULL,\n                transform_type TEXT NOT NULL,\n                params TEXT,\n                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n                FOREIGN KEY (input_hash) REFERENCES objects(hash),\n                FOREIGN KEY (output_hash) REFERENCES objects(hash)\n            );\n            \n            CREATE INDEX IF NOT EXISTS idx_objects_refs ON objects(refs);\n            CREATE INDEX IF NOT EXISTS idx_datasets_name ON datasets(name);\n            CREATE INDEX IF NOT EXISTS idx_transformations_input ON transformations(input_hash);\n            \"#\n        ).execute(&pool).await?;\n        \n        Ok(MetadataDb { pool })\n    }\n    \n    pub async fn register_object(&self, hash: &str, size: i64, metadata: Option<String>) -> Result<()> {\n        sqlx::query(\n            \"INSERT INTO objects (hash, size, metadata) VALUES (?, ?, ?)\n             ON CONFLICT(hash) DO UPDATE SET refs = refs + 1\"\n        )\n        .bind(hash)\n        .bind(size)\n        .bind(metadata)\n        .execute(&self.pool)\n        .await?;\n        Ok(())\n    }\n    \n    pub async fn find_datasets_by_name(&self, name: &str) -> Result<Vec<DatasetRecord>> {\n        let records = sqlx::query_as::<_, DatasetRecord>(\n            \"SELECT * FROM datasets WHERE name = ? ORDER BY created_at DESC\"\n        )\n        .bind(name)\n        .fetch_all(&self.pool)\n        .await?;\n        Ok(records)\n    }\n}\n```\n\n마이그레이션 시스템, 연결 풀링, 트랜잭션 지원 포함",
        "testStrategy": "스키마 생성 테스트, CRUD 연산 테스트, 참조 카운팅 정확성 테스트, 동시성 테스트, 마이그레이션 테스트",
        "priority": "medium",
        "dependencies": [
          6
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Nix 통합 및 심링크 팜 생성",
        "description": "Nix derivation과 CAS를 연결하는 심링크 팜 메커니즘 구현",
        "details": "lib/mkDataset.nix 완전 구현:\n```nix\n{ lib, pkgs, ... }:\n{ name, version, manifest, storePath ? null }:\nlet\n  manifestData = if builtins.isPath manifest\n                 then builtins.fromJSON (builtins.readFile manifest)\n                 else manifest;\n  \n  castStore = if storePath != null then storePath\n              else builtins.getEnv \"CAST_STORE\";\n  \n  hashToPath = hash: let\n    stripped = lib.removePrefix \"blake3:\" hash;\n  in \"${castStore}/store/${builtins.substring 0 2 stripped}/\" +\n     \"${builtins.substring 2 2 stripped}/${stripped}\";\n     \nin pkgs.stdenv.mkDerivation {\n  pname = \"cast-dataset-${name}\";\n  inherit version;\n  \n  phases = [ \"installPhase\" ];\n  \n  installPhase = ''\n    mkdir -p $out/data\n    \n    # manifest.json 복사\n    cp ${builtins.toFile \"manifest.json\" (builtins.toJSON manifestData)} $out/manifest.json\n    \n    # 각 파일에 대한 심링크 생성\n    ${lib.concatMapStrings (file: ''\n      target=\"${hashToPath file.hash}\"\n      if [ -e \"$target\" ]; then\n        mkdir -p \"$out/data/$(dirname ${file.path})\"\n        ln -s \"$target\" \"$out/data/${file.path}\"\n      else\n        echo \"Warning: Missing file ${file.hash}\" >&2\n      fi\n    '') manifestData.contents}\n  '';\n  \n  passthru = {\n    inherit manifest;\n    castDatasetName = lib.toUpper (lib.replaceStrings [\"-\"] [\"_\"] name);\n  };\n  \n  setupHook = pkgs.writeText \"setup-hook.sh\" ''\n    export CAST_DATASET_${lib.toUpper (lib.replaceStrings [\"-\"] [\"_\"] name)}=$1/data\n  '';\n}\n```\n\n환경변수 자동 설정, 중첩 디렉토리 구조 처리",
        "testStrategy": "nix build로 derivation 빌드 테스트, 심링크가 올바른 CAS 파일을 가리키는지 확인, 환경변수가 올바르게 설정되는지 테스트",
        "priority": "high",
        "dependencies": [
          3,
          6
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "변환 파이프라인 시스템 구현",
        "description": "데이터 변환을 위한 Nix 함수와 캐싱 메커니즘 구현",
        "details": "lib/transform.nix 구현:\n```nix\n{ lib, pkgs, cast-cli }:\n{ name, src, builder, outputs ? [\"out\"] }:\nlet\n  srcManifest = src.manifest or (builtins.fromJSON (builtins.readFile \"${src}/manifest.json\"));\nin pkgs.stdenv.mkDerivation {\n  pname = \"cast-transform-${name}\";\n  version = srcManifest.dataset.version or \"unknown\";\n  \n  inherit src builder;\n  \n  buildInputs = [ cast-cli ];\n  \n  phases = [ \"unpackPhase\" \"buildPhase\" \"installPhase\" ];\n  \n  unpackPhase = ''\n    # src 데이터를 작업 디렉토리로 복사/링크\n    cp -r ${src}/data/* .\n  '';\n  \n  buildPhase = ''\n    export CAST_OUTPUT=$PWD/output\n    mkdir -p $CAST_OUTPUT\n    \n    # 사용자 정의 builder 실행\n    ${builder}\n  '';\n  \n  installPhase = ''\n    # 출력을 CAS에 저장하고 manifest 생성\n    manifest=$(cast-cli transform \\\n      --input-manifest ${src}/manifest.json \\\n      --output-dir $CAST_OUTPUT \\\n      --transform-type \"${name}\")\n    \n    mkdir -p $out\n    echo \"$manifest\" > $out/manifest.json\n    \n    # 심링크 팜 생성\n    for file in $(find $CAST_OUTPUT -type f); do\n      rel_path=''${file#$CAST_OUTPUT/}\n      hash=$(cast-cli put \"$file\")\n      mkdir -p \"$out/data/$(dirname $rel_path)\"\n      ln -s \"$(cast-cli get-path $hash)\" \"$out/data/$rel_path\"\n    done\n  '';\n  \n  passthru = {\n    inherit srcManifest;\n    transformationType = name;\n  };\n}\n```\n\ncast-cli transform 명령어 구현, 변환 캐싱, provenance 추적",
        "testStrategy": "간단한 변환 (파일 복사) 테스트, 복잡한 변환 (압축 해제, 포맷 변환) 테스트, 캐싱이 작동하는지 확인, provenance 체인 검증",
        "priority": "low",
        "dependencies": [
          8
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "예제 및 문서화 완성",
        "description": "사용 예제, README, API 문서 작성으로 프로젝트 완성",
        "details": "examples/ 디렉토리 구성:\n\nexamples/simple-dataset/flake.nix:\n```nix\n{\n  inputs = {\n    nixpkgs.url = \"github:NixOS/nixpkgs/nixos-unstable\";\n    cast.url = \"path:../..\";\n  };\n  \n  outputs = { self, nixpkgs, cast }: {\n    packages.x86_64-linux.example-dataset = cast.lib.mkDataset {\n      name = \"test-data\";\n      version = \"1.0.0\";\n      manifest = ./manifest.json;\n    };\n  };\n}\n```\n\nexamples/transformation/flake.nix:\n```nix\n{\n  inputs = {\n    nixpkgs.url = \"github:NixOS/nixpkgs/nixos-unstable\";\n    cast.url = \"path:../..\";\n  };\n  \n  outputs = { self, nixpkgs, cast }:\n  let\n    pkgs = nixpkgs.legacyPackages.x86_64-linux;\n    \n    # NCBI 데이터베이스 다운로드\n    ncbiNr = cast.lib.fetchDatabase {\n      name = \"ncbi-nr\";\n      url = \"ftp://ftp.ncbi.nlm.nih.gov/blast/db/nr.tar.gz\";\n      extract = true;\n    };\n    \n    # MMseqs 데이터베이스로 변환\n    ncbiMmseqs = cast.lib.transform {\n      name = \"ncbi-to-mmseqs\";\n      src = ncbiNr;\n      builder = pkgs.writeShellScript \"convert\" ''\n        ${pkgs.mmseqs2}/bin/mmseqs createdb \\\n          ${ncbiNr}/data/nr.fasta \\\n          $CAST_OUTPUT/nr_mmseqs\n        \n        ${pkgs.mmseqs2}/bin/mmseqs createindex \\\n          $CAST_OUTPUT/nr_mmseqs \\\n          $CAST_OUTPUT/tmp\n      '';\n    };\n  in {\n    packages.x86_64-linux = {\n      ncbi-nr = ncbiNr;\n      ncbi-mmseqs = ncbiMmseqs;\n    };\n    \n    devShells.x86_64-linux.default = pkgs.mkShell {\n      buildInputs = [ pkgs.mmseqs2 ncbiMmseqs ];\n      shellHook = ''\n        echo \"NCBI MMseqs database available at: $CAST_DATASET_NCBI_TO_MMSEQS\"\n      '';\n    };\n  };\n}\n```\n\nREADME.md:\n- 설치 가이드\n- 빠른 시작 튜토리얼\n- API 레퍼런스\n- 아키텍처 설명\n- 기여 가이드라인\n\ncast-cli --help 출력 개선, man 페이지 생성",
        "testStrategy": "모든 예제가 nix build로 빌드되는지 테스트, 문서의 코드 스니펫이 실행 가능한지 확인, README의 설치 가이드를 따라 실제 설치 테스트",
        "priority": "low",
        "dependencies": [
          8,
          9
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-11-17T15:10:33.104Z",
      "updated": "2025-11-17T15:10:33.105Z",
      "description": "Tasks for master context"
    }
  }
}